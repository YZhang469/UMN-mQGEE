### custom functions in simulation

## load packages
library(MASS)
library(geepack)

#####################################
########## Data Generation ##########
#####################################

## generate a set of sequences of longitudinal data (Y0, A1, Y1, A2, Y2, Y3) from a joint distribution

generateData.joint <- function(N = 1000, # sample size 
                               alpha1 = 1, alpha2 = 1.5, alpha3 = 2, beta2 = 1, beta3 = 1.5, gamma2 = 1, gamma3 = 1.5, # coefficients of treatment effect
                               sigma.v = 2, sigma.e = 2, lambda1 = 0, lambda2 = 0, lambda3 = 0){ # parameters of correlation matrix
  Y0 <- rnorm(N, 0, 1)
  A1 <- 2*rbinom(N, 1, 0.5) - 1
  A2 <- 2*rbinom(N, 1, 0.5) - 1
  mu <- cbind(alpha1*Z1*A1, 
              alpha2*Z1*A1 + beta2*Z1*A2 + gamma2*A1*A2, 
              alpha3*Z1*A1 + beta3*Z1*A2 + gamma3*A1*A2)
  Sigma <- matrix(c(lambda1^2*sigma.v^2+sigma.e^2, lambda1*lambda2*sigma.v^2, lambda1*lambda3*sigma.v^2,
                    lambda1*lambda2*sigma.v^2, lambda2^2*sigma.v^2+sigma.e^2, lambda2*lambda3*sigma.v^2, 
                    lambda1*lambda3*sigma.v^2, lambda2*lambda3*sigma.v^2, lambda3^2*sigma.v^2+sigma.e^2), nrow = 3, ncol = 3)
  Y <- t(apply(mu, 1, function(x) mvrnorm(n = 1, mu = x, Sigma = Sigma))) # need MASS package
  dat <- cbind.data.frame("ID" = 1:N, "Z1" = Z1, "A1" = A1, "Y1" = Y[, 1],
                          "A2" = A2, "Y2" = Y[, 2], "Y3" = Y[, 3])
  return(dat)
}

############################
########## Method ##########
############################

## Q-learning algorithm without GEE, this algorithm analyzes a data set generated by "generateData.joint()"

weighted.sum <- function(x, w){ # x ~ n*p matrix, w ~ vector with p elements
  as.matrix(x) %*% w # return the weighted sum of each row
}

Q <- function(dat, 
              method = "SQ",  # method can have value "SQ" or "MQ"
              w = c(1/3, 1/3, 1/3), 
              misspec = FALSE){
  
  ## stage 2
  dat.s2 <- cbind.data.frame(dat[ , c("ID", "Z1", "A1", "Y1", "A2", "Y2", "Y3")], 
                             "Q2" = dat$Y2 + dat$Y3) # collapse repeated measures at the end of stage 2
  if (misspec){
    mod.s2 <- glm(Q2 ~ (Z1 + A1 + Y1) * A2, data = dat.s2) # time is not a covariate in collapsed outcome model
  }
  else{
    mod.s2 <- glm(Q2 ~ (Z1 * A1 + Y1) * A2, data = dat.s2)
  }
  dat.s2.opt <- dat.s2 # create a data set that performs optimal treatment and stores counterfactual outcomes at stage 2
  # if A2 = -1
  dat.s2a <- dat.s2
  dat.s2a$A2 <- -1
  dat.s2a$Q2 <- predict(mod.s2, newdata = dat.s2a)
  # if A2 = 1
  dat.s2b <- dat.s2
  dat.s2b$A2 <- 1
  dat.s2b$Q2 <- predict(mod.s2, newdata = dat.s2b)
  # identify stage 2 optimal rule
  Q2a <- dat.s2a$Q2
  Q2b <- dat.s2b$Q2
  dat.s2.opt$A2 <- ifelse(Q2a < Q2b, -1, 1)
  # estimate the counterfactual outcomes using standard or modified Q-learning
  if (method == "SQ"){
    # standard Q-learning uses predictions from stage 2 model
    dat.s2.opt$R2 <- predict(mod.s2, newdata = dat.s2.opt)
  }
  if (method == "MQ"){
    # modified Q-learning uses the observed values and adds back the regret function if the observed treatment is suboptimal
    int2 <- (Q2b - Q2a)/2
    dat.s2.opt$R2 <- dat.s2$Q2 - 2 * ifelse(dat.s2.opt$A2 == dat.s2$A2, 0, 1) * abs(int2)
  }
  
  ## stage 1
  dat.s1 <- cbind.data.frame(dat[ , c("ID", "Z1", "A1", "Y1")],
                             "A2" = dat.s2.opt$A2, # A2opt
                             "Q1" = weighted.sum(x = cbind.data.frame(dat$Y1, dat.s2.opt$R2), w = c(w[1], w[2] + w[3])))
  mod.s1 <- glm(Q1 ~ Z1 * A1, data = dat.s1)
  dat.s1.opt <- dat.s1 # create a data set that performs optimal treatment and stores counterfactual outcomes at stage 1
  # A2 = -1
  dat.s1a <- dat.s1
  dat.s1a$A1 <- -1
  dat.s1a$Q1 <- predict(mod.s1, newdata = dat.s1a)
  # A2 = 1
  dat.s1b <- dat.s1
  dat.s1b$A1 <- 1
  dat.s1b$Q1 <- predict(mod.s1, newdata = dat.s1b)
  # identify stage 1 optimal rule
  Q1a <- dat.s1a$Q1
  Q1b <- dat.s1b$Q1
  dat.s1.opt$A1 <- ifelse(Q1a < Q1b, -1, 1)
  if (method == "SQ"){
    # standard Q-learning uses predictions from stage 1 model
    dat.s1.opt$R1 <- predict(mod.s1, newdata = dat.s1.opt)
  }
  if (method == "MQ"){
    # modified Q-learning uses the observed values and adds back the regret function if the observed treatment is suboptimal
    int1 <- (Q1b - Q1a)/2
    dat.s1.opt$R1 <- dat.s1$Q1 - ifelse(dat.s1.opt$A1 == dat.s1$A1, 0, 1) * abs(int1)
  }
  # output a data frame which contains the estimated optimal rules and outcomes
  dat.opt <- cbind.data.frame(dat.s1.opt[ , c("ID", "Z1", "A1", "A2", "R1")])
  # output a list of model parameters, original data set, and estimated optimal counterfactuals
  return(list("mod.s1" = mod.s1, "mod.s2" = mod.s2, "dat" = dat, "dat.opt" = dat.opt))
}

## Q-learning methods with GEE, this algorithm analyzes a data set generated by "generateData.joint()"
# users can specify the working correlation that best fit their interest, but "unstructured" is recommended

QGEE <- function(dat, 
                 method = "SQGEE",  # method can have value "SQGEE" or "MQGEE"
                 corstr = c("unstructured", "exchangeable"), 
                 w = c(1/3, 1/3, 1/3), 
                 misspec = FALSE){
  n <- nrow(dat)
  
  ## stage 2
  # convert the format of the data set from wide to long
  dat.s2 <- cbind.data.frame(do.call(rbind, replicate(2, dat[ , c("ID", "Z1", "A1", "Y1", "A2", "Y2", "Y3")], simplify = FALSE)), 
                             "time" = rep(c(2, 3), each = n), "Q2" = c(dat$Y2, dat$Y3)) # treat repeated measures at the end of stage 2 as an outcome vector
  dat.s2 <- dat.s2[order(dat.s2$ID), ]
  if (misspec){
    mod.s2 <- geeglm(Q2 ~ factor(time) * (Z1 + A1 + Y1) * A2, data = dat.s2, id = ID, corstr = corstr[2])
  }
  else {
    mod.s2 <- geeglm(Q2 ~ factor(time) * (Z1 * A1 + Y1) * A2, data = dat.s2, id = ID, corstr = corstr[2])
  }
  dat.s2.opt <- dat.s2 # create a data set that performs optimal treatment and stores counterfactual outcomes at stage 2
  # A2 = -1
  dat.s2a <- dat.s2
  dat.s2a$A2 <- -1
  dat.s2a$Q2 <- predict(mod.s2, newdata = dat.s2a)
  # A2 = 1
  dat.s2b <- dat.s2
  dat.s2b$A2 <- 1
  dat.s2b$Q2 <- predict(mod.s2, newdata = dat.s2b)
  Q2a <- apply(matrix(dat.s2a$Q2, 2), 2, weighted.mean, w = w[2:3])
  Q2b <- apply(matrix(dat.s2b$Q2, 2), 2, weighted.mean, w = w[2:3])
  dat.s2.opt$A2 <- rep(ifelse(Q2a < Q2b, -1, 1), each = 2)
  if (method == "SQGEE"){
    # standard Q-learning uses predictions from stage 2 model
    dat.s2.opt$R2 <- predict(mod.s2, newdata = dat.s2.opt)
  }
  if (method == "MQGEE"){
    # modified Q-learning uses the observed values and adds back the regret function if the observed treatment is suboptimal
    int2 <- (dat.s2b$Q2 - dat.s2a$Q2)/2
    dat.s2.opt$R2 <- dat.s2$Q2 + 2 * ifelse(dat.s2.opt$A2 == dat.s2$A2, 0, 1) * dat.s2.opt$A2 * int2
  }
  dat.s2.opt <- dat.s2.opt[order(dat.s2.opt$time), ]
  
  ## stage 1
  dat.s1 <- cbind.data.frame(do.call(rbind, replicate(3, dat[ , c("ID", "Z1", "A1", "Y1")], simplify = FALSE)), 
                             "A2" = rep(dat.s2.opt$A2[1:n], 3), # A2opt
                             "time" = rep(c(1, 2, 3), each = n), 
                             "Q1" = c(dat$Y1, dat.s2.opt$R2))
  dat.s1 <- dat.s1[order(dat.s1$ID), ]
  mod.s1 <- geeglm(Q1 ~ factor(time) * Z1 * A1, data = dat.s1, id = ID, corstr = corstr[1]) # stage 1 full model
  dat.s1.opt <- dat.s1 # create a data set that performs optimal treatment and stores counterfactual outcomes at stage 1
  # A2 = -1
  dat.s1a <- dat.s1
  dat.s1a$A1 <- -1
  dat.s1a$Q1 <- predict(mod.s1, newdata = dat.s1a)
  # A2 = 1
  dat.s1b <- dat.s1
  dat.s1b$A1 <- 1
  dat.s1b$Q1 <- predict(mod.s1, newdata = dat.s1b)
  Q1a <- apply(matrix(dat.s1a$Q1, 3), 2, weighted.mean, w = w[1:3])
  Q1b <- apply(matrix(dat.s1b$Q1, 3), 2, weighted.mean, w = w[1:3])
  dat.s1.opt$A1 <- rep(ifelse(Q1a > Q1b, -1, 1), each = 3)
  if (method == "SQGEE"){
    # standard Q-learning uses predictions from stage 1 model
    dat.s1.opt$R1 <- predict(mod.s1, newdata = dat.s1.opt)
  }
  if (method == "MQGEE"){
    # modified Q-learning uses the observed values and adds back the regret function if the observed treatment is suboptimal
    int1 <- (dat.s1b$Q1 - dat.s1a$Q1)/2
    dat.s1.opt$R1 <- dat.s1$Q1 + 2 * ifelse(dat.s1.opt$A1 == dat.s1$A1, 0, 1) * dat.s1.opt$A1 * int1
  }
  # output a data frame which contains the estimated optimal rules and outcomes
  dat.opt <- cbind.data.frame(dat.s1.opt[ , c("ID", "Z1", "A1", "A2", "time", "R1")])
  # convert the format of dat.opt from long to wide
  dat.opt <- reshape(dat.opt, v.names = "R1",idvar = "ID", timevar = "time", direction = "wide", sep = "")
  # output a list of model parameters, original data set, and estimated optimal counterfactuals
  return(list("mod.s1" = mod.s1, "mod.s2" = mod.s2, "dat" = dat, "dat.opt" = dat.opt))
}

# check r-squared
calcR2 <- function(mod){
  r2 <- 1 - sum((mod$y - mod$fitted.values)^2)/sum((mod$y - mean(mod$y))^2)
  return(r2)
}
sumR2 <- function(sigma.v = 5, sigma.e = 3){
  R2.s2 <- rep(NA, 3)
  R2.s1 <- rep(NA, 3)
  dat <- generateData.joint(N = 30000,
                            alpha1 = -2.0, alpha2 = -1.7, alpha3 = -1.6, beta2 = 0, beta3 = 0, gamma2 = -1.2, gamma3 = -0.8, 
                            sigma.v = sigma.v, sigma.e = sigma.e, lambda1 = 1, lambda2 = 1, lambda3 = 1)
  R2.s2[1] <- calcR2(QGEE(dat, method = "SQGEE")$mod.s2)
  R2.s1[1] <- calcR2(QGEE(dat, method = "SQGEE")$mod.s1)
  dat <- generateData.joint(N = 30000,
                            alpha1 = -2.0, alpha2 = -1.7, alpha3 = -1.6, beta2 = 0, beta3 = 0, gamma2 = -1.2, gamma3 = -0.8, 
                            sigma.v = sigma.v, sigma.e = sigma.e, lambda1 = 0, lambda2 = 0, lambda3 = 0)
  R2.s2[2] <- calcR2(QGEE(dat, method = "SQGEE")$mod.s2)
  R2.s1[2] <- calcR2(QGEE(dat, method = "SQGEE")$mod.s1)
  dat <- generateData.joint(N = 30000,
                            alpha1 = -2.0, alpha2 = -1.7, alpha3 = -1.6, beta2 = 0, beta3 = 0, gamma2 = -1.2, gamma3 = -0.8, 
                            sigma.v = sigma.v, sigma.e = sigma.e, lambda1 = 1, lambda2 = -1, lambda3 = -1)
  R2.s2[3] <- calcR2(QGEE(dat, method = "SQGEE")$mod.s2)
  R2.s1[3] <- calcR2(QGEE(dat, method = "SQGEE")$mod.s1)
  return(list("R2.s1" = R2.s1, "R2.s2" = R2.s2))
}
# sumR2(sigma.v = 4.4, sigma.e = 2.7)

#############################
########## Metrics ##########
#############################

## define metrics to assess the performance of a method: PCI, RMSE, bias
# PCI is applicable to output of both functions "Q" and "QGEE", whereas RMSE and bias are only applicable to output of "QGEE"

metric <- function(output, w = c(1/3, 1/3, 1/3), 
                   alpha1, alpha2, alpha3, beta2, beta3, gamma2, gamma3, 
                   sigma.v, sigma.e, lambda1, lambda2, lambda3){
  
  # probability of correctly identifying (PCI) the stage-specific optimal rule
  d2opt <- ifelse((w[2]*beta2+w[3]*beta3) * output$dat$Z1 + (w[2]*gamma2+w[3]*gamma3) * output$dat$A1 > 0, -1, 1) # true optimal rule at stage 2, as a function of Z1 and A1
  pci.s2 <- sum(output$dat.opt$A2 == d2opt) / nrow(output$dat.opt) # stage 2 PCI
  d1 <- function(a1){ # function to calculate the true value of average repeated-measures outcomes given baseline covariate Y0 and treatment A1 = a1, A2 = d2opt
    v <- ((w[1]*alpha1+w[2]*alpha2+w[3]*alpha3) *  output$dat$Z1 + 
            (gamma2+gamma3) * ifelse((w[2]*beta2+w[3]*beta3) * output$dat$Z1 + (w[2]*gamma2+w[3]*gamma3) * a1 > 0, -1, 1)) * a1
    return(v)
  }
  d1opt <- ifelse(d1(-1) < d1(1), -1, 1) # true optimal rule at stage 1, assuming that optimal rule is followed at stage 2
  pci.s1 <- sum(output$dat.opt$A1 == d1opt) / nrow(output$dat.opt) # stage 1 PCI
  
  # root mean square error (RMSE) of heterogeneous causal effect estimators
  delta1 <- 2*alpha1*output$dat.opt$Z1 # true stage 1 individual treatment effects at time 1
  delta2 <- 2*alpha2*output$dat.opt$Z1 # true stage 1 individual treatment effects at time 2, evaluated at ESTIMATED stage 2 optimal rule
  delta3 <- 2*alpha3*output$dat.opt$Z1 # true stage 1 individual treatment effects at time 3, evaluated at ESTIMATED stage 2 optimal rule
  # estimated stage 1 heterogeneous treatment effect
  dat <- cbind.data.frame(do.call(rbind, replicate(3, output$dat.opt[ , c("ID", "Z1", "A1")], simplify = FALSE)), 
                          "time" = rep(c(1, 2, 3), each = nrow(output$dat.opt)))
  dat <- dat[order(dat$ID), ]
  dat1 <- dat
  dat1$A1 <- 1
  dat0 <- dat
  dat0$A1 <- -1
  delta.hat <- matrix(predict(output$mod.s1, newdata = dat1), ncol = 3, byrow = TRUE) - matrix(predict(output$mod.s1, newdata = dat0), ncol = 3, byrow = TRUE)
  # calculate RMSE
  rmse1 <- sqrt(mean((delta.hat[, 1] - delta1)^2))
  rmse2 <- sqrt(mean((delta.hat[, 2] - delta2)^2))
  rmse3 <- sqrt(mean((delta.hat[, 3] - delta3)^2))
  rmse <- c(rmse1, rmse2, rmse3) # RMSE of heterogeneous stage 1 causal effects at times 1, 2, 3, respectively
  
  # bias of heterogeneous causal effect estimators
  Z1.grid <- c(-3, -2, -1, 0, 1, 2, 3)
  # matrix to store bias
  bias.mat <- matrix(NA, nrow = 3, ncol = length(Z1.grid))
  # true stage 1 individual treatment effects at times 1, 2, 3, respectively, based on TRUE stage 2 optimal rule
  delta1 <- 2*alpha1*Z1.grid
  delta2 <- 2*alpha2*Z1.grid + gamma2*(ifelse((w[2]*beta2+w[3]*beta3)*Z1.grid+w[2]*gamma2+w[3]*gamma3 > 0, -1, 1) + ifelse((w[2]*beta2+w[3]*beta3)*Z1.grid-w[2]*gamma2-w[3]*gamma3 > 0, -1, 1)) # calculate A2opt analytically
  delta3 <- 2*alpha3*Z1.grid + gamma3*(ifelse((w[2]*beta2+w[3]*beta3)*Z1.grid+w[2]*gamma2+w[3]*gamma3 > 0, -1, 1) + ifelse((w[2]*beta2+w[3]*beta3)*Z1.grid-w[2]*gamma2-w[3]*gamma3 > 0, -1, 1))
  # estimated stage 1 individual treatment effects
  dat1.psd <- cbind.data.frame("Z1" = rep(Z1.grid, each = 3), "A1" = rep(1, length(Z1.grid)*3), "time" = rep(c(1, 2, 3), length(Z1.grid))) # pseudo data
  dat0.psd <- cbind.data.frame("Z1" = rep(Z1.grid, each = 3), "A1" = rep(-1, length(Z1.grid)*3), "time" = rep(c(1, 2, 3), length(Z1.grid)))
  delta.hat <- matrix(predict(output$mod.s1, newdata = dat1.psd), ncol = 3, byrow = TRUE) - matrix(predict(output$mod.s1, newdata = dat0.psd), ncol = 3, byrow = TRUE)
  # store bias values
  bias.mat[1, ] <- delta.hat[, 1] - delta1
  bias.mat[2, ] <- delta.hat[, 2] - delta2
  bias.mat[3, ] <- delta.hat[, 3] - delta3
  
  # return the calculated metrics
  return(list("pci.s2" = pci.s2, "pci.s1" = pci.s1, "rmse" = rmse, "bias.mat" = bias.mat))
}
